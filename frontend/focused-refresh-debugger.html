<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîç Focused Refresh Debugger</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 20px; 
            background: #f8f9fa;
        }
        .alert { 
            padding: 15px; 
            margin: 10px 0; 
            border-radius: 5px; 
            font-weight: bold; 
        }
        .alert.danger { 
            background: #f8d7da; 
            color: #721c24; 
            border: 1px solid #f5c6cb; 
        }
        .alert.success { 
            background: #d4edda; 
            color: #155724; 
            border: 1px solid #c3e6cb; 
        }
        .alert.warning { 
            background: #fff3cd; 
            color: #856404; 
            border: 1px solid #ffeaa7; 
        }
        .metrics { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); 
            gap: 10px; 
            margin: 20px 0; 
        }
        .metric { 
            background: white; 
            padding: 15px; 
            border-radius: 5px; 
            text-align: center; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
        }
        .metric-value { 
            font-size: 24px; 
            font-weight: bold; 
            color: #2c3e50; 
        }
        .console { 
            background: #2c3e50; 
            color: #ecf0f1; 
            padding: 15px; 
            border-radius: 5px; 
            font-family: monospace; 
            max-height: 300px; 
            overflow-y: auto; 
            margin: 20px 0; 
        }
        button { 
            background: #3498db; 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            border-radius: 5px; 
            cursor: pointer; 
            margin: 5px; 
        }
        button:hover { 
            background: #2980b9; 
        }
    </style>
</head>
<body>
    <h1>üîç Focused Refresh Debugger</h1>
    <div id="alert-container"></div>
    
    <div class="metrics">
        <div class="metric">
            <div class="metric-value" id="vite-pings">0</div>
            <div>Vite Pings</div>
        </div>
        <div class="metric">
            <div class="metric-value" id="network-requests">0</div>
            <div>Network Requests</div>
        </div>
        <div class="metric">
            <div class="metric-value" id="console-errors">0</div>
            <div>Console Errors</div>
        </div>
        <div class="metric">
            <div class="metric-value" id="dom-mutations">0</div>
            <div>DOM Changes</div>
        </div>
    </div>
    
    <button onclick="openContributePage()">üìù Open Contribute Page</button>
    <button onclick="openMainApp()">üè† Open Main App</button>
    <button onclick="resetCounters()">üîÑ Reset Counters</button>
    <button onclick="analyzeRefreshPattern()">üîç Analyze Pattern</button>
    
    <div id="console-output" class="console">Starting focused refresh debugger...\n</div>

    <script>
        let vitePings = 0;
        let networkRequests = 0;
        let consoleErrors = 0;
        let domMutations = 0;
        let refreshPattern = [];
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const console = document.getElementById('console-output');
            const prefix = type === 'error' ? 'üö®' : type === 'warn' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            console.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            console.scrollTop = console.scrollHeight;
        }
        
        function updateMetric(id, value, threshold = null) {
            const element = document.getElementById(id);
            element.textContent = value;
            
            if (threshold && value > threshold) {
                element.style.color = '#e74c3c';
                element.parentElement.style.background = '#fff5f5';
            } else {
                element.style.color = '#2c3e50';
                element.parentElement.style.background = 'white';
            }
        }
        
        function showAlert(message, type = 'warning') {
            const container = document.getElementById('alert-container');
            const alert = document.createElement('div');
            alert.className = `alert ${type}`;
            alert.textContent = message;
            container.appendChild(alert);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (alert.parentNode) {
                    alert.parentNode.removeChild(alert);
                }
            }, 10000);
        }
        
        // Monitor network requests with focus on refresh-causing patterns
        const originalFetch = window.fetch;
        window.fetch = function(url, options) {
            networkRequests++;
            updateMetric('network-requests', networkRequests);
            
            const urlStr = typeof url === 'string' ? url : url.toString();
            
            // Track Vite HMR pings specifically
            if (urlStr.includes('/_vite/ping')) {
                vitePings++;
                updateMetric('vite-pings', vitePings, 5);
                log(`Vite HMR ping #${vitePings}`);
                
                // Track ping frequency
                refreshPattern.push({ type: 'vite-ping', time: Date.now() });
                
                if (vitePings > 10) {
                    showAlert('üö® EXCESSIVE VITE PINGS! This indicates continuous refresh issues.', 'danger');
                } else if (vitePings > 5) {
                    showAlert('‚ö†Ô∏è High Vite ping activity detected. Monitor for refresh issues.', 'warning');
                }
            }
            
            // Monitor other potentially problematic requests
            if (urlStr.includes('nominatim') || urlStr.includes('geocod')) {
                log(`Geocoding API call: ${urlStr.split('?')[0]}`);
            }
            
            if (urlStr.includes('hot-update')) {
                log('Hot module replacement detected');
                refreshPattern.push({ type: 'hmr', time: Date.now() });
            }
            
            return originalFetch.apply(this, arguments);
        };
        
        // Monitor DOM mutations for excessive changes
        const mutationObserver = new MutationObserver((mutations) => {
            const significantMutations = mutations.filter(m => 
                m.type === 'childList' && m.addedNodes.length > 0
            );
            
            if (significantMutations.length > 0) {
                domMutations += significantMutations.length;
                updateMetric('dom-mutations', domMutations, 50);
                
                if (significantMutations.length > 10) {
                    log(`High DOM mutation activity: ${significantMutations.length} changes`);
                }
            }
        });
        
        mutationObserver.observe(document.body, {
            childList: true,
            subtree: true
        });
        
        // Monitor console errors
        const originalConsoleError = console.error;
        console.error = function(...args) {
            consoleErrors++;
            updateMetric('console-errors', consoleErrors, 0);
            log(`Console error: ${args.join(' ')}`, 'error');
            
            if (consoleErrors === 1) {
                showAlert('Console errors detected. Check for JavaScript issues.', 'danger');
            }
            
            originalConsoleError.apply(this, args);
        };
        
        // Functions
        function openContributePage() {
            window.open('http://localhost:3002/contribute', '_blank');
            log('Opened contribute page - monitor for refresh issues');
        }
        
        function openMainApp() {
            window.open('http://localhost:3002', '_blank');  
            log('Opened main application');
        }
        
        function resetCounters() {
            vitePings = 0;
            networkRequests = 0;
            consoleErrors = 0;
            domMutations = 0;
            refreshPattern = [];
            
            updateMetric('vite-pings', 0);
            updateMetric('network-requests', 0);
            updateMetric('console-errors', 0);
            updateMetric('dom-mutations', 0);
            
            document.getElementById('alert-container').innerHTML = '';
            log('All counters reset');
            showAlert('Counters reset successfully', 'success');
        }
        
        function analyzeRefreshPattern() {
            log('üîç REFRESH PATTERN ANALYSIS:');
            
            if (refreshPattern.length === 0) {
                log('No refresh activity detected');
                showAlert('No refresh patterns found. This is good!', 'success');
                return;
            }
            
            // Analyze timing patterns
            const now = Date.now();
            const recentEvents = refreshPattern.filter(e => now - e.time < 60000); // Last minute
            
            if (recentEvents.length > 20) {
                log(`üö® HIGH FREQUENCY: ${recentEvents.length} refresh events in last minute`);
                showAlert('üö® CRITICAL: Very high refresh frequency detected!', 'danger');
            } else if (recentEvents.length > 10) {
                log(`‚ö†Ô∏è MODERATE FREQUENCY: ${recentEvents.length} refresh events in last minute`);
                showAlert('‚ö†Ô∏è Moderate refresh activity - investigate components', 'warning');
            } else {
                log(`‚úÖ NORMAL FREQUENCY: ${recentEvents.length} refresh events in last minute`);
                showAlert('‚úÖ Refresh frequency appears normal', 'success');
            }
            
            // Group by type
            const byType = {};
            recentEvents.forEach(e => {
                byType[e.type] = (byType[e.type] || 0) + 1;
            });
            
            Object.entries(byType).forEach(([type, count]) => {
                log(`${type}: ${count} occurrences`);
            });
        }
        
        // Auto-analysis every 30 seconds
        setInterval(analyzeRefreshPattern, 30000);
        
        log('Focused refresh debugger ready');
        log('üëÄ Monitoring Vite HMR pings, network requests, DOM changes, and console errors');
        showAlert('Debug tool is monitoring. Open the contribute page to test.', 'success');
    </script>
</body>
</html>